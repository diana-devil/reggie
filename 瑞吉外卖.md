# 瑞吉外卖后台

### 项目基础

<img src="D:\生活\学习\西电杭研院\云共享\OneDrive\文档\云共享\代码库\java\项目\瑞吉外卖\images\功能架构.png" style="zoom:50%;" />

<img src="D:\生活\学习\西电杭研院\云共享\OneDrive\文档\云共享\代码库\java\项目\瑞吉外卖\images\技术选型.png" alt="技术选型" style="zoom:50%;" />

<img src="D:\生活\学习\西电杭研院\云共享\OneDrive\文档\云共享\代码库\java\项目\瑞吉外卖\images\角色信息.png" alt="角色信息" style="zoom:50%;" />

##### 数据表

![数据表](D:\生活\学习\西电杭研院\云共享\OneDrive\文档\云共享\代码库\java\项目\瑞吉外卖\images\数据表.png)

### 知识点补充

##### 日志

`@Slf4j`—— `lombok`提供，可以直接调用`log.info`等作为日志输出

##### mybatisplus

* 命名对应

```yml
map-underscore-to-camel-case: true   #在映射实体或者属性时，将数据库表名和字段名中的下划线去掉，按照驼峰命名法命名
```

* service层继承

```java
public interface EmployeeService extends IService<Employee> {
}
```

```java
public class EmployeeServiceImpl extends ServiceImpl<EmployeeMapper, Employee> implements EmployeeService {
}
```

##### 前端

* 数据存储——将信息存入浏览器

```js
//将信息存储到浏览器 ——Application/Storage/Local Storage/http://localhost
localStorage.setItem('userInfo',JSON.stringify(res.data))
```

<img src="D:\生活\学习\西电杭研院\云共享\OneDrive\文档\云共享\java\项目\瑞吉外卖\images\浏览器存储信息.png" alt="浏览器存储信息" style="zoom:50%;" />

* 从浏览器取出数据——并将json数据转换成js对象

```js
//从浏览器取出存储的数据
const userInfo = window.localStorage.getItem('userInfo')
if (userInfo) {
    this.userInfo = JSON.parse(userInfo)
}
```

### 后台登陆登出功能

##### 后台登陆

* 逻辑分析

<img src="D:\生活\学习\西电杭研院\云共享\OneDrive\文档\云共享\java\项目\瑞吉外卖\images\后台登陆方法.png" alt="后台登陆方法" style="zoom:75%;" />

* md5加密
  * `DigestUtils.md5DigestAsHex(password.getBytes());`调用工具类进行md5加密

```java
public R<Employee> login(HttpServletRequest request, @RequestBody Employee employee){
    /**
     * 1.将页面提交的密码进行md5加密处理
     * 2.根据页面提交的用户名username查询数据库
     * 3.如果没有查询到则返回登陆失败结果
     * 4.密码对比，如果不一致则返回登陆失败结果
     * 5.查看员工状态，如果为已禁用，则返回员工已禁用结果
     * 6.登陆成功，将员工id存入Session并返回登陆成功结果
     */

    //1.将页面提交的密码进行md5加密处理
    String password = employee.getPassword();
    password=DigestUtils.md5DigestAsHex(password.getBytes());
    //2.根据页面提交的用户名username查询数据库
    LambdaQueryWrapper<Employee> queryWrapper=new LambdaQueryWrapper<>();
    queryWrapper.eq(Employee::getUsername,employee.getUsername());
    Employee emp = service.getOne(queryWrapper);
    //3.如果没有查询到则返回登陆失败结果
    if (emp!=null){
        if (password.equals(emp.getPassword())){
            if(emp.getStatus()==1){
                //6.登陆成功，将员工id存入Session并返回登陆成功结果
                HttpSession session = request.getSession();
                session.setAttribute("id",emp.getId());
                return R.success(emp);
            }else{
                //5.查看员工状态，如果为已禁用，则返回员工已禁用结果
                return R.error("您已被禁用，请联系管理员！");
            }
        }else{
            //4.密码对比，如果不一致则返回登陆失败结果
            return R.error("密码不正确！");
        }
    }else{
        //3.如果没有查询到则返回登陆失败结果
        return R.error("用户名不存在！");
    }
}
```

##### 完善登陆功能

* 用户登陆前，要检查登陆状态，只有登陆成功，才能访问到数据，不成功的话，要返回登陆页面——使用过滤器开

   > 1. 在启动类上加，`@ServletComponentScan//启动过滤器`，可以扫到到过滤器
   >
   >  2. `@WebFilter(filterName = "loginCheckFilter",urlPatterns = "/*")`，过滤器头上挂个注解
   >
   >  3. 需要放行的资源  每个资源前面都要加"/"，加上“/”才算是一个完整路径
   >
   >  4. 路径匹配器` public static final AntPathMatcher PATH_MATCHER =new AntPathMatcher();`
   >
   >     使用` boolean match = PATH_MATCHER.match(url, RequestURI);`可以识别出通配符 `**`
   >
   >  5. 在controller中不用json转换，因为加了注解`@responsbody`,会将对象自动转换为json数据，但是这里没有加，所以需要自己将对象转换成json数据
   >
   >     `response.getWriter().write(JSON.toJSONString(R.error("NOTLOGIN")));`——使用fastjson技术转换json

```java
/**
 * 使用过滤器
 * 检查用户是否已经完成登录
 */
@Slf4j
@WebFilter(filterName = "loginCheckFilter",urlPatterns = "/*")
public class LoginCheckFilter implements Filter {

    //路径匹配器,可以识别通配符
    public static final AntPathMatcher PATH_MATCHER =new AntPathMatcher();


    /***
     * 完善登录功能，保证在没登录之前，无法获取数据
     * @param servletRequest
     * @param servletResponse
     * @param filterChain
     * @throws IOException
     * @throws ServletException
     */
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {


        HttpServletRequest request =(HttpServletRequest) servletRequest;
        HttpServletResponse response =(HttpServletResponse) servletResponse;

        //需要放行的资源  每个资源前面都要加"/"
        String[] urls=new String[]{
                "/employee/login",
                "/employee/logout",
                "/backend/**",
                "/front/**"
        };


        //1.获取本次请求的uri,直接放行登录页面；其他请求，判断session中的id，
        String requestURI = request.getRequestURI();
//        log.info("拦截到请求：{}",requestURI);
        //2.判断本次请求是否需要处理
        boolean check = check(urls, requestURI);
//        log.info("{}",check);
        //3.如果不需要处理，则直接放行
        if(check){
//            log.info("无需处理，直接放行！");
            filterChain.doFilter(request,response);
            return;
        }
        //4.判断登录状态，如果登录完成，则直接放行
        if(request.getSession().getAttribute("id")!=null){
//            log.info("用户登录成功！！");
            filterChain.doFilter(request,response);
            return;
        }
        //5.如果未登录，则返回登录结果（前端定义了重定向到登录页面，所有只需要返回结果就好）
        //通过输出流的方式想客户端页面响应数据
        //在controller中不用json转换，spring会将对象自动转换为json数据，但是在外面不行，需要自己将对象转换成json数据
        response.getWriter().write(JSON.toJSONString(R.error("NOTLOGIN")));
//        log.info("返回登录页面！");
        return;
    }


    /***
     * 路径匹配，检查本次请求是否需要处理
     * @param urls
     * @param RequestURI
     * @return
     */
    public boolean check(String[] urls,String RequestURI){
        for(String url:urls){
            boolean match = PATH_MATCHER.match(url, RequestURI);
            if(match){
                return true;
            }
        }
        return false;
    }
}
```

##### 后台登出

* 退出记得要清空 session
  * `removeAttribute("id")`

```java
@PostMapping("/logout")
public R<String> logout(HttpServletRequest request){
    /**
     * 1.清理session中的id
     * 2.返回退出
     */

    //1.清理session中的id.
    request.getSession().removeAttribute("id");
    //2.返回退出
    return R.success("退出成功！！");

}
```

### 员工管理页面

##### 新增员工

> 1. 获取当前时间——》`LocalDateTime.now()`生成时间格式的当前时间，可以直接与数据库的datetime类型进行交互
>
> 2. 异常捕获——》加注解 `@RestControllerAdvice(annotations = {RestController.class, Controller.class})`
>
>    捕获并处理全局异常。

```java
/**
 * 新增员工
*/
@PostMapping
public R<String> save(@RequestBody Employee employee,HttpServletRequest request){
    //1.完善员工信息
    String idNumber = employee.getIdNumber();
    String pas = idNumber.substring(idNumber.length() - 6);
    log.info(pas);
    DigestUtils.md5DigestAsHex(pas.getBytes());//进行md5加密
    employee.setPassword(pas);//默认密码身份证号后6位-加密后
    employee.setStatus(1);//设置状态为1
    employee.setCreateTime(LocalDateTime.now());//设置创建时间
    employee.setUpdateTime(LocalDateTime.now());//设置修改时间
    Long id = (Long)request.getSession().getAttribute("id");
    employee.setCreateUser(id);
    employee.setUpdateUser(id);

    log.info("员工信息{}",employee);
    //2.将员工信息添加进数据库
    service.save(employee);
    return R.success("添加员工成功！");
}
```

```java
/**
 * 全局异常处理类
 */

//拦截加了这些controller的类
@RestControllerAdvice(annotations = {RestController.class, Controller.class})
@Slf4j
public class GroupExceptionHandler {

    /***
     * 异常处理方法
     * @return
     */
    @ExceptionHandler(SQLIntegrityConstraintViolationException.class)
    public R<String> exceptionHandler_SQL(SQLIntegrityConstraintViolationException ex){

       log.error(ex.getMessage());

       if(ex.getMessage().contains("Duplicate entry")){
           String username = ex.getMessage().split(" ")[2];
            username = username.substring(1, username.length()-1);
           return R.error("账号 "+username+" 重复");
       }

       return R.error("其他类型错误");
    }
```

##### 员工信息分页查询

> 1. 前台需要的实体类型  刚好与mybatisplus分页查询返回的Page对象一样，所以将T 设为Page
> 2. 调用分页查询 `service.page(pageInfo, lqw);` 
>    * `pageInfo`是一个Page对象
>    * `lqw`是查询条件

```java
/***
     * 员工信息分页查询
     * @param page 第几页
     * @param pageSize 每页显示数量
     * @param name 查询名称
     * @return
     */
    @GetMapping("/page")
    public R<Page> getEmpByPage(int page, int pageSize,String name){
        //name 可不传， 不传为null
        log.info("{},{},{}",page,pageSize,name);

        //构造分页构造器
        Page pageInfo=new Page(page,pageSize);
        //构造条件构造器
        LambdaQueryWrapper<Employee> lqw=new LambdaQueryWrapper<>();
        //添加过滤条件
        lqw.like(name!=null,Employee::getName,name);
        //添加排序条件
        lqw.orderByDesc(Employee::getUpdateTime);
        Page page1 = service.page(pageInfo, lqw);

        return R.success(page1);

    }
```

##### 启用/禁用员工账号

> 1. 雪花算法生成的id Long类型，19位，但是JS响应数据只能保证前16位的精度，后面3位精度缺失，导致id识别不准确，需要自定义对象映射器来解决
> 2. 自定义对象映射器，针对该问题的解决方案，将long类型的id转换成字符串类型，存入json
> 3. ` service.updateById(employee);`,该方法传入的是一个对象，会根据其内部属性值进行修改，为null的不会动，只修改有值的

```java
/***
 * 根据id修改员工信息
 *
 * 雪花算法生成id Long类型，19位
 * 但是JS响应数据只能保证，前16位精确，后面3为精度缺失
 * @param employee
 * @return
 */
@PutMapping
public R<String> Update(@RequestBody Employee employee,HttpServletRequest request){

    //设置更新时间和更新人
    Long id = (Long)request.getSession().getAttribute("id");
    employee.setUpdateUser(id);
    employee.setUpdateTime(LocalDateTime.now());
    //这个更新操作，只修改不为null的操作，为null的不会修改，放心大胆的用即可
    service.updateById(employee);
    return R.success("修改成功！！");
}
```

```java
public class JacksonObjectMapper extends ObjectMapper {

    public static final String DEFAULT_DATE_FORMAT = "yyyy-MM-dd";
    public static final String DEFAULT_DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm:ss";
    public static final String DEFAULT_TIME_FORMAT = "HH:mm:ss";

    public JacksonObjectMapper() {
        super();
        //收到未知属性时不报异常
        this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);

        //反序列化时，属性不存在的兼容处理
        this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);


        SimpleModule simpleModule = new SimpleModule()
                .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))

                .addSerializer(BigInteger.class, ToStringSerializer.instance)
                .addSerializer(Long.class, ToStringSerializer.instance)//将Long型数据转换成String类型，存入json
                .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));

        //注册功能模块 例如，可以添加自定义序列化器和反序列化器
        this.registerModule(simpleModule);
    }
}
```

##### 编辑员工信息

> 1. 编辑前，进行数据回显
> 2. 编辑员工信息和新增员工信息，采用的是一个方法 `Update`——`PutMapping`
> 3. 前端帮忙解决的小问题
>    * 截取路径上的id，作为参数传给后台
>    * 数据库存储的性别是0,1，在显示的时候，转成了男，女

```java
/**
 * 根据id查询员工数据
 * 为数据回显做准备
 * @param id
 * @return
 */
@GetMapping("/{id}")
public R<Employee> GetById(@PathVariable Long id){
    Employee employee = service.getById(id);
    return R.success(employee);
}
```

```js
//获取url地址上面的参数
function requestUrlParam(argname){
  var url = location.href
  var arrStr = url.substring(url.indexOf("?")+1).split("&")
  for(var i =0;i<arrStr.length;i++)
  {
      var loc = arrStr[i].indexOf(argname+"=")
      if(loc!=-1){
          return arrStr[i].replace(argname+"=","").replace("?","")
      }
  }
  return ""
}
```

```js
this.ruleForm.sex = res.data.sex === '0' ? '女' : '男'
```

### 分类管理页面

##### 公共字段自动填充

* 问题

  > * 对于一些公共字段，如 修改人，创建人，修改时间，创建时间等，很多表都有这么个字段，每次都要书写很麻烦
  >
  > * 所以mybtisplus 提供了公共字段自动填充功能，只需要书写一次，其他设计的操作都会自动执行

* `ThreadLocal`

  * 客户端每发送一次http请求，对应的在服务端就会分配一个新的线程来处理
  * 过滤器，新增，自定义元数据处理器,三个方法属于同一次http请求的过程，**因此属于同一个线程**
  * 所以这些方法之间可以通过**线程域**，来传送一些信息

  ![ThreadLocal](D:\生活\学习\西电杭研院\云共享\OneDrive\文档\云共享\java\项目\瑞吉外卖\images\ThreadLocal.png)

* 使用方法

  1. 在要自动修改（公共字段）的属性名上加注解。

     ```java
     @TableField(fill = FieldFill.INSERT) //插入时填充字段
     private LocalDateTime createTime;
     
     @TableField(fill = FieldFill.INSERT_UPDATE)//插入和更新时填充字段
     private LocalDateTime updateTime;
     
     @TableField(fill = FieldFill.INSERT) //插入时填充字段
     private Long createUser;
     
     @TableField(fill = FieldFill.INSERT_UPDATE)//插入和更新时填充字段
     private Long updateUser;
     ```

  2. 编写`ThreadLocal`封装工具类，获取登陆用户id

     * 过滤器，新增，自定义元数据处理器,三个方法属于同一次http请求的过程，**因此属于同一个线程**
     * 每一个线程都有一个独自的`threadLocal`,可以将数据存入，供其他方法调用

     * 工具类中 对象和方法都使用静态的，这样可以直接用类来调用方法，不需要new一个对象

     ```java
     /**
      * 基于ThreadLocal 封装工具类，用户保存和获取当前登陆用户的id
      */
     public class BaseContext {
         private static ThreadLocal<Long> threadLocal=new ThreadLocal<>();
     
         public static  void  setThreadLocal(Long id){
             threadLocal.set(id);
         }
     
         public static  Long getCurrentId(){
             return  threadLocal.get();
         }
     }
     ```

  3. 编写自定义元数据处理器，实现自动填充。

     * 实现一个接口——`MetaObjectHandler`
     * 设置公共字段的值——`metaObject.setValue("updateTime", LocalDateTime.now());`
     * 从线程域中获取登陆用户id——`BaseContext.getCurrentId()`   因为这个类中无法获取session对象，所以要从线程域中取值

     ```java
     /**
      * 自定义元数据处理器
      */
     @Component
     @Slf4j
     public class MyMetaObjectHandler implements MetaObjectHandler {
     
         /**
          * 插入操作自动填充
          * @param metaObject
          */
         @Override
         public void insertFill(MetaObject metaObject) {
     //        log.info("公共字段自动填充……");
     //        log.info(metaObject.toString());
     //        log.info("线程id{}",Thread.currentThread().getId());//输出当前id值
             metaObject.setValue("createTime", LocalDateTime.now());
             metaObject.setValue("updateTime", LocalDateTime.now());
             metaObject.setValue("createUser", BaseContext.getCurrentId()); //从线程域中获取登陆用户id
             metaObject.setValue("updateUser", BaseContext.getCurrentId());
         }
     
         /**
          * 更新操作自动填充
          * @param metaObject
          */
         @Override
         public void updateFill(MetaObject metaObject) {
     
             metaObject.setValue("updateTime", LocalDateTime.now());
             //从线程域中获取登陆用户id
             metaObject.setValue("updateUser", BaseContext.getCurrentId());
     
         }
     }
     ```

##### 新增分类

```java
/**
 * 新增分类
 * 1-菜品分类
 * 2-套餐分类
 * @param category
 * @return
 */
@PostMapping
public R<String> addCategory(@RequestBody Category category){
    log.info(category.toString());
    categoryService.save(category);
    return R.success("新增分类成功");
}
```

##### 分类信息分页查询

* 按照多个条件排序

  > 可以使用级联的方式，使用多个`.orderByAsc`--升序

```java
/***
 * 分类管理
 * 分页查询
 * @return
 */
@GetMapping("/page")
public R<IPage<Category>> getCategoryByPage(int page, int pageSize){
    log.info("{},{}",page,pageSize);

    //创建分页对象   传入 当前页page    当前页面大小 pageSize
    IPage<Category> page1=new Page<Category>(page,pageSize);

    //定义查询条件
    LambdaQueryWrapper<Category> queryWrapper=new LambdaQueryWrapper<>();
    queryWrapper.orderByAsc(Category::getSort)
                .orderByAsc(Category::getUpdateTime); //按排名排序,排名一样的按修改时间排序，都是生序
    //调用分页查询方法
    IPage<Category> page2 = categoryService.page(page1, queryWrapper);

    log.info(page2.toString());

    return R.success(page2);
}
```

##### 删除分类

* 1.逻辑删除

  > * 将逻辑删除字段配置写在 配置文件中
  >
  >   ```yml
  >   logic-delete-field: isDeleted  #表示逻辑删除的属性
  >   logic-delete-value: 1   #表示删除的默认值
  >   logic-not-delete-value: 0  #表示不删除的默认值
  >   ```
  >
  > * 写在每个类的属性头上 (不推荐)
  >
  >   ```java
  >   @TableLogic(value = "0",delval = "1")//默认是0 0表示未删除，1表示删除
  >   private Integer isDeleted;
  >   ```

* 2.逻辑外键——service

  > * 一般数据库不推荐使用外键，会影响效率，所以要使用逻辑外键来弥补，
  > * 即删除前进行逻辑判断，将逻辑判读的代码写到service层
  > * 如果关联了菜品或套餐，要抛出自定义异常
  > * 在全局异常处理中捕获抛出的异常，并返回适当的结果
  > * 在`CategoryServiceImpl`中调用`CategoryService`的方法，要使用`super`，不要使用`@Autowired`注入,会报错

  ```java
  /**
   * 自定义业务异常
   *
   * 当删除分类包含菜品或者套餐的时候，抛出
   */
  public class CustomException extends RuntimeException{
      public CustomException(String message){
          super(message);
      }
  }
  ```

  ```java
  /**
   * 捕获 自定义异常
   * @param ex
   * @return
   */
  @ExceptionHandler(CustomException.class)
  public R<String> exceptionHandler_Cus(CustomException ex){
      log.error(ex.getMessage());
      return R.error(ex.getMessage());
  }
  ```

  ```java
  /**
   * 根据id删除分类，删除之前需要判断
   * @param id
   */
  public void remove(Long id){
  
      //查询当前分类是否关联了菜品，如果关联了，则抛出异常
      LambdaQueryWrapper<Dish> queryWrapper_Dish=new LambdaQueryWrapper<>();
      queryWrapper_Dish.eq(Dish::getCategoryId,id);
      long count1 = dishService.count(queryWrapper_Dish);
      log.info("{}",count1);
      if(count1>0){
          //抛出业务异常
          throw new CustomException("所选分类关联了菜品，不能删除！");
      }
      //查询当前分类是否关联了套餐，如果关联了，则抛出异常
      LambdaQueryWrapper<Setmeal> queryWrapper_Setmeal=new LambdaQueryWrapper<>();
      queryWrapper_Setmeal.eq(Setmeal::getCategoryId,id);
      long count2 = dishService.count(queryWrapper_Dish);
      log.info("{}",count2);
      if(count2>0){
          //抛出业务异常
          throw new CustomException("所选分类关联了套餐，不能删除！");
      }
      //逻辑删除分类
      super.removeById(id);//调用父类————categoryService.removeById(id);
  }
  ```

* 3. Controller层代码

  ```java
  /**
   * 删除分类--在service层使用了
   * 需要使用逻辑外键，判断分类是否关联了菜品，
   * @return
   */
  @DeleteMapping
  public R<String> deleteCategory(Long ids){
      categoryService.remove(ids);
      return R.success("删除成功！！");
  }
  ```

##### 修改分类

* 回显数据的工作，前端帮忙做了，所以后端不用回显数据了

```java
/**
 * 通过前端vue框架 实现了数据回显
 *  修改分类
 * @return
 */
@PutMapping
public R<String> updateCategory(@RequestBody Category category){
    log.info(category.toString());

    if (categoryService.updateById(category)){
        return R.success("修改成功！");
    }else{
        return R.error("修改失败！");
    }

}
```

### 菜品管理

##### [文件上传](D:\生活\学习\西电杭研院\云共享\OneDrive\文档\云共享\代码库\java\SSM框架\SpringMVC\SpringMVC.md)

* 前端要求

  ![](D:\生活\学习\西电杭研院\云共享\OneDrive\文档\云共享\代码库\java\项目\瑞吉外卖\images\文件上传前端要求.png)

  * 通常会使用到 `commons-io`和`commons-fileupload`

* 后端代码

  * 读取参数类型 必须是  `MultipartFile`,是Spirng-web封装好的处理文件的类型,参数名要和表单中的name对应起来，这里前端name=file

  * 获取文件后缀名 `originalFilename.substring(originalFilename.lastIndexOf("."));`

  * 使用UUID生成随机数，创造随机文件名 `UUID.randomUUID().toString() + suffix;`

  * 处理目录对象，判断是否存在，若不存在，则创建，` dir.mkdir();`

  * 文件夹目录，写在配置文件中，解耦，使用`@Value("${reggie.filepath}")`读取

    ```yml
    reggie:  #不要加双引号
      filepath: D:\生活\学习\西电杭研院\云共享\OneDrive\文档\云共享\代码库\java\项目\瑞吉外卖\images\dish\img\
    ```

  ```java
  
  @Value("${reggie.filepath}") //读取配置文件中的定义的路径值
  private String basePath;
  
  
  /**
  * 文件上传
  *
  * @param file 参数类型必须是 MultipartFile，是Spirng-web封装好的处理文件的类型
  * @return
  */
  
  @PostMapping("/upload")
  public R<String> upload(MultipartFile file){ //属性名与 表单提交文件的name名一致
      //file 是一个临时文件，需要转存到指定位置，否则本次请求完成后临时文件会自动消失
  
      //获取文件后缀名
      String originalFilename =file.getOriginalFilename();
      String suffix = originalFilename.substring(originalFilename.lastIndexOf("."));
      //        log.info(suffix);
  
      //使用uuid重新生成文件名，防止文件名重复造成文件覆盖
      String fileName = UUID.randomUUID().toString() + suffix;
  
      //处理目录对象
      File dir=new File(basePath);
      if(!dir.exists()){
          //如果目录不存在，创建目录
          dir.mkdir();
      }
  
      //将文件转存到指定位置
      try {
          file.transferTo(new File(basePath+fileName));
      } catch (IOException e) {
          e.printStackTrace();
      }
      return  R.success(fileName);
  
  }
  ```

##### 文件下载

* 文件下载方式
  * 方式1： 以附件的形式下载，保存到本地
  * 方式2:  以流的方式输出到浏览器，直接在浏览器中打开
  * 这里采用的是方式2
* 代码实现1——从底层写起，文件io流操作

```java
/**
     * 文件下载
     * 方式1： 以附件的形式下载，保存到本地
     * 方式2:  以流的方式输出到浏览器，直接在浏览器中打开
     *
     * 这里采用的是 方式2 在浏览器展示图片
     * @param name
     * @param response
     */
@GetMapping("/download")
public void download(String name, HttpServletResponse response){
    //        log.info(name);

    try {
        //输入流，通过输入流读取文件内容
        FileInputStream fileInputStream = new FileInputStream(new File(basePath + name));
        //输出流，通过输出流写回浏览器，在浏览器展示图片
        ServletOutputStream outputStream = response.getOutputStream();

        //设置响应格式  图片格式
        response.setContentType("image/jpeg");

        int len=0;
        byte[] bytes =new byte[1024];

        //将输入流读入 字节数组，一次读入1024个字节，最后一次不足1024的剩余字节数，再读就是-1
        while((len=fileInputStream.read(bytes)) !=-1){
            log.info("{}",len);
            outputStream.write(bytes,0,len);
            outputStream.flush();
        }
        //关闭资源
        outputStream.close();
        fileInputStream.close();

    } catch (Exception e) {
        e.printStackTrace();
    }
}
```

* 代码实现2——使用copy方法

  ```java
  //使用方法copy  ----commons-io  方法内部跟上面自己手动实现copy流基本一样
  IOUtils.copy(fileInputStream,outputStream); //完成从输入流到输出流的copy
  
  
  
  //替代下面代码
  //设置响应格式  图片格式
  response.setContentType("image/jpeg");
  
  int len=0;
  byte[] bytes =new byte[1024];
  
  //将输入流读入 字节数组，一次读入1024个字节，最后一次不足1024的剩余字节数，再读就是-1
  while((len=fileInputStream.read(bytes)) !=-1){
      log.info("{}",len);
      outputStream.write(bytes,0,len);
      outputStream.flush();
  }
  ```

##### 新增菜品

* Controller

  ```java
  /**
   * 添加菜品
   * @return
   */
  @PostMapping
  public R<String> addDish(@RequestBody DishDto dishDto){
      log.info(dishDto.toString());
      dishService.saveWithFlavor(dishDto);
      return  R.success("添加成功");
  }
  ```

* Service

  * 因为网页传来的数据同时包含了菜品和菜品口味两张表，一个菜品实体类接收不了，所以要创建一个dto，继承自dish，同时封装菜品口味和其他内容。
  * **同时操作两张表，记得开事务。`@Transactional`**
  *  在service 层中调用自己的方法，使用this，`this.save(dishDto);` 
    * **这里虽然 `dishDto`中的属性要多于`dish`中的属性，但是可以直接调用`dish`的save方法，它会从里面挑出dish的属性，并封装好，存好，不需要自己把属性一个个的拿出来在封装。**
  * 因为网页中得到的`dishDto.getFlavors()`不含dishID，所以要对数据进行修改。
    * 可以使用for循环的方法
    * **也可以使用steam流方法**
  * mybatisplus 有批量保存方法，`saveBatch(flavors);`，不要傻傻的用for循环一个个去save了

  ```java
  /**
   * 用于封装页面提交的数据
   *
   * dto   即数据传输对象
   * 一般用于展示层与服务层之间的数据传输
   *
   */
  @Data
  public class DishDto extends Dish {
  
      //口味列表
      private List<DishFlavor> flavors = new ArrayList<>();
  
      //菜品分类名称  Dish里面是id
      private String categoryName;
  
      //
      private Integer copies;
  }
  ```

  ```java
  /**
       * 新增菜品，同时插入菜品和对应的口味数据，需要操作两张表：dish,dish_flavor
       * @param dishDto
       */
  @Transactional
  public void saveWithFlavor(DishDto dishDto){
      //保存菜品的基本信息到菜品表dish
      this.save(dishDto);
  
      //获取 dish_id
      Long disID = dishDto.getId(); //获取父类-菜品的id
  
      //将集合中每个dishId赋值--for循环方法
      //        for(DishFlavor dishFlavor:dishDto.getFlavors()){
      //            dishFlavor.setDishId(disID);
      //        }
      //将集合中每个dishId赋值--steam流方法
      List<DishFlavor> flavors = dishDto.getFlavors();
      flavors=flavors.stream().map((item)->{
          item.setDishId(disID);
          return item;
      }).collect(Collectors.toList());
  
  
      //保存菜品口味数据到菜品口味表 dish_flavor
      //批量保存
      dishFlavorService.saveBatch(flavors);
  }
  ```

##### 菜品信息分页查询

* 前端需要 分类名称，而`Page<Dish>`只能提供id值，所以要创建一个`Page<DishDto>`对象来获取分类名称
* 属性copy方法，  `BeanUtils.copyProperties(pageinfo,dishDtoPageinfo,"records");`
* 调用分页查询方法page时，`dishService.page(pageinfo, queryWrapper);`里面传入了分页对象`pageinfo`,方法会修改`pageinfo`对象的值，不需要在创建一个新的对象
* 为分类名称`categoryName`赋值
  * 将`Page<Dish>`对象copy给`Page<DishDto>`,忽略属性`records`
  * 使用流的方式从每个records中取出id值，查询得到name值，并赋值给categoryName；同时将records中的其他属性copy给dishDto对象。
  * 然后将这些对象收集起来转换成list集合，`List<DishDto> dtoLis`,即为records。
  * 原先records中存的是一批Dish类型的数据，相当于`List<Dish>`,现在records中存的是一批Dishdto类型的数据，相当于`List<DishDto>`

```java
/**
     * 菜品分页查询
     * 这里不能简单的返回Page<Dish>, 因为这里面没有对应的 分类名称只有分类id
     * 所以创建一个Page<DishDto>对象，将Page<Dish>的数据进行简单处理。
     * @param page 第几页
     * @param pageSize 每页显示多少
     * @return  page对象
     */
@GetMapping("/page")
public R<Page<DishDto>> getDishByPage(int page,int pageSize,String name){

    //创建分页对象
    Page<Dish> pageinfo=new Page<>(page,pageSize);
    Page<DishDto> dishDtoPageinfo=new Page<>();

    //创建查询条件
    LambdaQueryWrapper<Dish> queryWrapper=new LambdaQueryWrapper<>();
    queryWrapper.like(name!=null,Dish::getName,name);

    //创建排序条件
    queryWrapper.orderByDesc(Dish::getUpdateTime);

    //查询数据
    //        Page<Dish> page1 = dishService.page(pageinfo, queryWrapper);
    //        log.info(page1.getRecords().toString());

    //这里不用返回一个page对象，pageinfo对象就已经是我们需要的对象了，数据都存好了
    dishService.page(pageinfo, queryWrapper);
    log.info(pageinfo.getRecords().toString());


    //对Page<DishDto> 进行处理
    //1.对象copy，忽略records
    BeanUtils.copyProperties(pageinfo,dishDtoPageinfo,"records");//忽略records，即copy除这个属性以外的所有值
    //2.从原来的records中获取categoryId，进一步获取分类名称
    List<Dish> records = pageinfo.getRecords();

    List<DishDto> dtoList=records.stream().map((item)->{
        //创建dishdto对象，将其他属性从records 中copy到dishdto对象中
        DishDto dishDto=new DishDto();
        BeanUtils.copyProperties(item,dishDto);

        //得到分类id
        Long categoryId = item.getCategoryId();

        //根据分类id 获取分类名称，并将dishDto进行设置
        Category category = categoryService.getById(categoryId);
        if(category!=null){
            dishDto.setCategoryName(category.getName());
        }
        return dishDto;
    }).collect(Collectors.toList());//将集合转换成list集合对象，并收集起来 赋值给dtolist

    //3.将设置好的records存入 Page<DishDto>对象
    dishDtoPageinfo.setRecords(dtoList);//将dtolist设置为新的records

    return  R.success(dishDtoPageinfo);
}
```

##### 回显数据

* Controller

  ```java
  /**
   * 根据id查询 菜品信息，和菜品对应口味信息
   * 查两个表
   * 修改菜品，回显请求
   * @param id
   * @return
   */
  @GetMapping("/{id}")
  public R<DishDto> getDishById(@PathVariable Long id){
      log.info("{}",id);
  
      //调用service 层方法
      DishDto dishDto = dishService.getByIdWithFlavor(id);
  
      return R.success(dishDto);
  }
  ```

* Service

  * 根据查询菜品基本信息
  * 根据dish_id查询菜品口味基本信息
  * 将两类信息封装搭配 dto对象中

  ```java
  /**
   *  根据id来查询菜品信息和对应的口味信息
   * @param id
   * @return
   */
  public DishDto getByIdWithFlavor(Long id){
  
      //查询出菜品基本信息
      Dish dish = this.getById(id);
  
      //查询出口味列表
      LambdaQueryWrapper<DishFlavor> queryWrapper=new LambdaQueryWrapper<>();
      queryWrapper.eq(DishFlavor::getDishId,id);
      List<DishFlavor> dishFlavors = dishFlavorService.list(queryWrapper);
  
      //进行对象封装
      DishDto dishDto=new DishDto(); //新建dishDto对象
      BeanUtils.copyProperties(dish,dishDto);//copy父类dish的属性
      dishDto.setFlavors(dishFlavors);//封装自己独有的口味信息
  
      return dishDto;
  
  }
  ```

##### 修改菜品

* Controller

  ```java
  /**
   * 修改菜品 提交请求
   * @param dishDto
   * @return
   */
  @PutMapping
  public R<String> updateDish(@RequestBody DishDto dishDto){
  
      log.info(dishDto.toString());
      //调用service 方法
      dishService.updateWithFlavor(dishDto);
  
      return R.success("修改成功！！");
  }
  ```

* Service

  * 这里虽然说是更新操作，但是在更新菜品口味表的时候，一个菜品id对应多个口味信息，逐个修改很麻烦

  * **可以采用先删除，在保存的方法，我们不关心对方有没有修改，只保存数据即可,这样逻辑非常简单。**

    > * 如果采用先删除在更新的话，不能简单的启用逻辑删除，因为这样保存不了原来的口味信息，会造成主键冲突
    >
    >   * 一开始就直接删除原有的口味信息，置逻辑删除字段为1，表示删除，但是id字段还存在
    >
    >   * 在保存口味信息，如果还是原来的口味信息id，没有删除后重建，那么会按照原来的id存，但是原来id是存在的，违反了主键约束
    >
    >   * 可以使用直接删除，来解决这个问题
    >
    > * 如果想用逻辑删除的话，需要将传入的口味信息的id置为null，这样save方法会自动生成一个id，就不会违反主键约束。

  * 使用流的方式 补充每个菜品口味中的`dish_id`

  ```java
  /**
   * 更新菜品信息和口味信息 需要操作两张表：dish,dish_flavor
   * 将原来的口味信息 全部删除，在保存提交过来的新的口味信息，这样比直接修改要简单的多
   * @param dishDto
   */
  @Transactional
  public void updateWithFlavor(DishDto dishDto){
      //更新菜品信息
      this.updateById(dishDto);
  
      //得到dish_id
      Long dishId = dishDto.getId();
  
      //删除原来的口味信息 ----删除dish-对应的口味信息
      LambdaQueryWrapper<DishFlavor> queryWrapper=new LambdaQueryWrapper<>();
      queryWrapper.eq(DishFlavor::getDishId,dishId);
      dishFlavorService.remove(queryWrapper);
  
  
      //添加提交过来的口味数据
      List<DishFlavor> flavors = dishDto.getFlavors();
      //补充flavors中的dish_id
      flavors=flavors.stream().map((item)->{
          //将菜品口味自带的id置为null，save方法去重写生成id，这样配合逻辑删除使用，否则会造成主键冲突
          item.setId(null);
          item.setDishId(dishId);
          return item;
      }).collect(Collectors.toList());
      //更新菜品口味信息
      dishFlavorService.saveBatch(flavors);
  }
  ```

##### 销售状态修改

* 停售，起售，批量起售，批量停售复用一个方法

* 大前端给我们传递了要修改的status，不需要自己去查了，直接用即可

* 这里在修改之前不需要考虑菜品原有的销售状态，不需要给员工报错提醒，直接更新即可

  ```java
  /**
       * 修改菜品销售状态
       * 这里前端给我们传递了要修改的状态值，直接用即可
       *
       * 起售，停售，批量起售，批量停售 复用一个方法
       * 对于选中的多个 进行批量起售，可以直接设置所选的为起售，不需要考虑原来的状态
       *
       * @param status
       * @param ids
       * @return
       */
      @PostMapping("/status/{status}")
      public R<String> updateStatus(@PathVariable int status,Long[] ids){
          for(Long id:ids){
              //根据id查出dish对象
              Dish dish = dishService.getById(id);
  
              //修改status  前端没传信息 ，自己从数据库中获取信息，并修改
  //        Integer status = dish.getStatus();
  //        dish.setStatus((status==1) ? 0:1); //如果状态是1，改为0；如果状态是0，改为1
              //修改status,前端传了信息，直接修改
              dish.setStatus(status);
              dishService.updateById(dish);
          }
  
          //修改成功
          return R.success("修改状态成功！");
      }
  ```

##### 删除菜品

* 单个删除和批量删除复用一个方法

* 删除不需要考虑删除失败的问题，即不需要考虑被其他员工删除的问题，因为都是删除，只要删除了就可以，不需要考虑是谁删除的

  ```java
  /**
       * 删除菜品信息
       * 删除单个与批量删除 复用一个方法
       *
       * @param ids
       * @return
       */
      @DeleteMapping
      @Transactional
      public R<String> deleteDish(Long[] ids){
          //如果没有删除成功
          //多人操作，一个人删除了，另外一个人没有刷新页面，也点击删除，就会出现删除失败的现象
          //这种请求 删除不需要报错，因为关心的是删了吗，谁删都一样
          for(Long id:ids){
  //            //如果删除有一个失败 就返回失败，终止操作
  //            if(!dishService.removeById(id)){
  //                return R.error("当前菜品已删除，请刷新后重试！！");
  //            }
              dishService.removeById(id);
          }
          //全部删除完成，没有任何问题，返回删除成功
          return R.success("删除成功！！");
      }
  ```

### 套餐管理

##### 新增套餐

* DishController
  * 在新增页面 根据菜系id `categoryId`,查询得到当前菜系所拥有的菜品，封装成list集合，返回给前端
  * **传参数的时候，最好传入 Dish对象，因为这样复用性更好**
  * **在查询菜品的时候，记得要加一个 销售状态为1的查询条件**

```java
/**
 *  根据categoryId,查询菜品名称
 * @param dish Dish 对象，现阶段只有categoryId一个值，但是复用性更好
 * @return R<List<Dish>>  对应菜系id的全部菜品信息
 */
@GetMapping("/list")
public R<List<Dish>> getDishList(Dish dish){

    //创建查询对象
    LambdaQueryWrapper<Dish> queryWrapper=new LambdaQueryWrapper<>();
    //根据当前的categoryId 查询所有 在售卖阶段的菜品
    queryWrapper.eq(dish.getCategoryId()!=null,Dish::getCategoryId,dish.getCategoryId());
    queryWrapper.eq(Dish::getStatus,1);
    //排序条件
    queryWrapper.orderByAsc(Dish::getSort);//按排序 越小越好
    queryWrapper.orderByDesc(Dish::getUpdateTime);//按更新时间，越大越好
    //查询所有满足条件的排列好的数据
    List<Dish> dishes = dishService.list(queryWrapper);

    return R.success(dishes);
}
```

* Setmealservice 层
  * 和新增菜品几乎一模一样，就是使用dto对象，先将继承的父类属性的信息存到表setmeal
  * 再将自己独有的列表数据，用流的方法设置setmeal_id后，保存到表setmeal_dish

```java
/**
     * 新增套餐信息，涉及到setmeal 套餐表，和setmeal_dish 套餐内部菜品表
     *
     * @param setmealDto dto对象 其继承了父类Setmeal的全部属性，又封装了菜系名称和菜品列表
     */
    public void saveWithDish(SetmealDto setmealDto){
        //将其继承的父类属性，保存到套餐分类 表setmeal
        this.save(setmealDto);

        //得到setmeal_id
        Long setmealId = setmealDto.getId();

        //需要设置 setmeal_id
        List<SetmealDish> setmealDishes = setmealDto.getSetmealDishes();
        setmealDishes=setmealDishes.stream().map((item)->{
            item.setSetmealId(setmealId);
            return item;
        }).collect(Collectors.toList());

//        log.info(setmealDishes.toString());
        //将套餐对应的菜品信息存入setmeal_dish表中
        setmealDishService.saveBatch(setmealDishes);
    }
```

* SetmealController 层 

```java
/**
 *  新增套餐信息，涉及到setmeal 套餐表，和setmeal_dish 套餐内部菜品表
 * @param setmealDto  dto对象 其继承了父类Setmeal的全部属性，又封装了菜系名称和菜品列表
 * @return
 */
@PostMapping
public R<String> addSetMeal(@RequestBody SetmealDto setmealDto){
    //调用service层方法
    setmealService.saveWithDish(setmealDto);
    return R.success("添加成功");
}
```

##### 套餐分页查询

* Controller层

```java
/**
 *  套餐分类 分页查询
 * @param page  当前页
 * @param pageSize 页面显示数量
 * @param name 套餐名称
 * @return  R<Page<SetmealDto>>
 */
@GetMapping("/page")
public R<Page<SetmealDto>> getMealByPage(int page,int pageSize,String name){

    //调用service层方法，完成分页查询
    Page<SetmealDto> mealByPage = setmealService.getMealByPage(page, pageSize, name);

    return R.success(mealByPage);
}
```

* Service层
  * 和菜品分页查询基本都一样，使用dto对象。

```java
/**
     * 对套餐进行分页查询，得到分页对象
     *
     * @param page 当前页
     * @param pageSize 每页显示数量
     * @param name 套餐名称 进行模糊查询
     * @return 返回分页对象
     */
    public Page<SetmealDto> getMealByPage(int page, int pageSize, String name ){
        //新建Page<Setmeal>对象
        Page<Setmeal> pageinfo=new Page<>(page,pageSize);
        //查询条件
        LambdaQueryWrapper<Setmeal> queryWrapper=new LambdaQueryWrapper<>();
        queryWrapper.like(name!=null,Setmeal::getName,name);
        //排序条件
        queryWrapper.orderByDesc(Setmeal::getUpdateTime);
        //分页查询
        this.page(pageinfo,queryWrapper);


        //新建Page<SetmealDto>对象，不光要继承原page对象的属性，还有加入categoryName
        Page<SetmealDto> dtoPage=new Page<>();
        BeanUtils.copyProperties(pageinfo,dtoPage,"records");//复制原属性，排除records
        List<Setmeal> records = pageinfo.getRecords();//得到原records对象
        List<SetmealDto> setmealDtos=records.stream().map((item)->{
            //得到 categoryName
            Long categoryId = item.getCategoryId();
            Category category = categoryMapper.selectById(categoryId);
            String categoryName = category.getName();
//            String categoryName ="儿童套餐";

            //将 categoryName 存入对象SetmealDto,并将records中其他属性copy到该对象中
            SetmealDto setmealDto=new SetmealDto();
            setmealDto.setCategoryName(categoryName);
            BeanUtils.copyProperties(item,setmealDto);

            return setmealDto;
        }).collect(Collectors.toList());

        //将setmealDtos作为dtoPage的records
        dtoPage.setRecords(setmealDtos);

        return dtoPage;
    }
```

##### 删除套餐

* Service层
  * 第一个是老师写的，多了一个对售卖状态的判断
  * **还有就是使用批量删除**  批量删除，查表次数少，效率更高

```java
/**
 * 删除套餐1
 * 删除前，判断一下菜品是否在售卖中，如果没有在售卖在删除
 * 删除套餐前应该先删除表stemeal_dish中对应的数据
 *然后在删除 表setmeal的数据， 开事务
 * @param ids
 * @return
 */
@Transactional
public void deleteWithDish(List<Long> ids){
    LambdaQueryWrapper<Setmeal> queryWrapper=new LambdaQueryWrapper<>();
    //查询状态为1 的且 id在被批量删除的ids中的
    queryWrapper.in(Setmeal::getId,ids).eq(Setmeal::getStatus,1);
    //查询满足上述要求的数量
    long count = this.count(queryWrapper);
    if(count>0){
        //如果不能删除，抛出一个业务异常
        throw new CustomException("套餐正在售卖中,不能删除！");
    }
    //能删除，删除表setmeal,直接批量删除
    this.removeByIds(ids);
    //删除表 setmeal_dish ,直接批量删除
    LambdaQueryWrapper<SetmealDish> lambdaQueryWrapper=new LambdaQueryWrapper<>();
    lambdaQueryWrapper.in(SetmealDish::getSetmealId,ids);
    setmealDishService.remove(lambdaQueryWrapper);

}
```

```java
/**
 * 删除套餐1
 * 删除套餐前应该先删除表stemeal_dish中对应的数据
 *然后在删除 表setmeal的数据， 开事务
 * @param ids
 * @return
 */
@Transactional
public void deleteWithDish(Long[] ids){
    for (Long id:ids){
        //删除表 stemeal_dish 中套餐对应的菜品信息
        LambdaQueryWrapper<SetmealDish> queryWrapper=new LambdaQueryWrapper<>();
        queryWrapper.eq(SetmealDish::getSetmealId,id);
        setmealDishService.remove(queryWrapper);
        //删除表 stemeal 中的套餐信息
        this.removeById(id);
    }

}
```

* Controller
  * 因为网页传的是数组形式数据，所以使用数组可以直接接
  * 但是转换成list集合的话，需要使用`@RequestParam List<Long> ids`

```java
/**
     * 删除套餐
     * 删除套餐前应该先删除套餐对应的菜品表 即 stemeal_dish中对应的数据
     *然后在删除 表setmeal的数据， 开事务
     * @param ids
     * @return
     */
@DeleteMapping
public R<String> deleteMeal(@RequestParam List<Long> ids){
    //    public R<String> deleteMeal(Long[] ids){
    //调用service 层方法
    setmealService.deleteWithDish(ids);
    return R.success("删除成功！");
}
```

##### 修改套餐

* 数据回显

  * Contrller

  ```java
  /**
   * 修改套餐的 数据回显
   * 使用dto对象
   * @param id
   * @return
   */
  @GetMapping("/{id}")
  public R<SetmealDto> getMealAndDish(@PathVariable Long id){
  
      //调用service层方法
      SetmealDto setmealDto = setmealService.getMealAndDish(id);
  
      return R.success(setmealDto);
  }
  ```

  * Service
    * 同 修改菜品的回显

  ```java
  /**
   * 修改套餐的数据回显功能
   * @param id
   */
  public SetmealDto getMealAndDish(Long id){
      //创建一个setmealDto 对象
      SetmealDto setmealDto=new SetmealDto();
  
      //1、查询setmeal表,并封装到dto对象中
      Setmeal setmeal = this.getById(id);
      BeanUtils.copyProperties(setmeal,setmealDto);
  
      //2、查询setmeal_dish表，并封装到dto对象中
      LambdaQueryWrapper<SetmealDish> queryWrapper=new LambdaQueryWrapper<>();
      queryWrapper.eq(SetmealDish::getSetmealId,id);
      List<SetmealDish> dishes = setmealDishService.list(queryWrapper);
      setmealDto.setSetmealDishes(dishes);
  
      return setmealDto;
  
  }
  ```

* 数据更新

  * Contrller

  ```java
  /**
   * 修改套餐
   * @param setmealDto
   * @return
   */
  @PutMapping
  public R<String> updateMealAndDish(@RequestBody SetmealDto setmealDto){
  
      setmealService.updateMealAndDish(setmealDto);
      return R.success("修改成功");
  
  }
  ```

  * Service
    * 同 菜品信息修改
    * 先修改父类信息，直接传dto对象即可
    * 接着删除原有的setmeal_dish表中的数据
    * 然后将网页到的的菜品数据，id置空，设置`setmeal_id`，然后批量存储

  ```java
  /**
   * 提交修改套餐的数据，并修改套餐
   * @param setmealDto
   */
  public void updateMealAndDish(SetmealDto setmealDto){
  
      //修改父类的属性信息
      this.updateById(setmealDto);
  
      //得到setmeal_id
      Long setmealId = setmealDto.getId();
  
      //删除原有的菜品信息
      LambdaQueryWrapper<SetmealDish> queryWrapper=new LambdaQueryWrapper<>();
      queryWrapper.eq(SetmealDish::getSetmealId,setmealId);
      setmealDishService.remove(queryWrapper);
  
  
      //需要设置 setmeal_id,同时将 id设为null
      List<SetmealDish> setmealDishes = setmealDto.getSetmealDishes();
      setmealDishes=setmealDishes.stream().map((item)->{
          item.setId(null);
          item.setSetmealId(setmealId);
          return item;
      }).collect(Collectors.toList());
  
  
      //将套餐对应的菜品信息存入setmeal_dish表中
      setmealDishService.saveBatch(setmealDishes);
  
  }
  ```

##### 修改销售状态

* 同菜品 修改销售状态

```java
/**
 * 修改销售状态
 * @param ids
 * @return
 */
@PostMapping("/status/{status}")
public R<String> updateStatus(Long[] ids,@PathVariable int status){

    for(Long id:ids){
        Setmeal setmeal = setmealService.getById(id);
        setmeal.setStatus(status); //修改销售状态
        setmealService.updateById(setmeal);//保存修改的信息
    }

    return R.success("修改状态成功！");
}
```

### 移动端登陆

##### 短信发送

* 将手机号和对应的验证码以键值对的形式放入session中，后期可以优化 使用redis

```java
/**
     *  发送短信验证码
     *  前端传入 phone，封装进user中
     * @param user
     * @return
     */
@PostMapping("/sendMsg")
public R<String> sendMsg(@RequestBody User user, HttpServletRequest request){
    log.info(user.toString());
    //获取登陆手机号
    String phone = user.getPhone();
    if(StringUtils.hasText(phone)){
        //如果手机号不为空
        //随机生成验证码
        Integer code = ValidateCodeUtils.generateValidateCode(6);
        //将验证码存入session域中，方便后期比对  键为手机号，值为验证码
        log.info("{}",code);
        request.getSession().setAttribute(user.getPhone(),code);
        //调用阿里云提供的短信服务API发送短信
        //            SMSUtils.sendMessage(SignName,TemplateCode,phone,code.toString());

        return R.success("短信发送成功！");
    }
    return R.error("手机号错误！");

}
```

* **静态方法调用配置文件中的值**
  * 首先要明确
    * 静态方法只能调用静态变量
    * 只有成员变量才能直接读取配置文件的值
  * 所以静态方法调用配置文件的值分为4步
    * 1. 声明成员变量，使用`@Value`获取配置文件的值
      2. 声明静态变量
      3. 使用get方法和`@PostConstruct`，将成员变量赋值给静态变量
      4. 从静态方法中引用静态变量

```java
public class SMSUtils {

   //从配置文件读取数据
   @Value("${SMS.accessKeyId}")
   private String accessKeyId1;
   @Value("${SMS.secret}")
   private String secret1;

   //声明静态变量，静态方法只能调用静态变量
   private static  String accessKeyId;
   private static String secret;

   //通过get方法，给静态变量赋值
   @PostConstruct
   public void getAccessKeyId(){
      accessKeyId=this.accessKeyId1;
   }
   @PostConstruct
   public void getSecret(){
      secret=this.secret1;
   }


   /**
    * 发送短信
    * @param signName 签名
    * @param templateCode 模板
    * @param phoneNumbers 手机号
    * @param param 参数
    */
   public static void sendMessage(String signName, String templateCode,String phoneNumbers,String param){

      DefaultProfile profile = DefaultProfile.getProfile("cn-hangzhou", accessKeyId, secret);
      IAcsClient client = new DefaultAcsClient(profile);

      SendSmsRequest request = new SendSmsRequest();
      request.setSysRegionId("cn-hangzhou");
      request.setPhoneNumbers(phoneNumbers);
      log.info(phoneNumbers);
      request.setSignName(signName);
      request.setTemplateCode(templateCode);
      request.setTemplateParam("{\"code\":\""+param+"\"}");
      try {
         SendSmsResponse response = client.getAcsResponse(request);
         System.out.println("短信发送成功");
      }catch (ClientException e) {
         e.printStackTrace();
      }
   }

}
```

##### 手机验证码登陆

* **调用save方法，保存用户数据时，会更新user对象**
  * 原来user对象是没有id的，存储的时候会自动生成id，存入到数据库中
  * 这时候，原来的user对象的id也不是null了，而是生成的id
* 在存入user对象时，判断是否为新用户
* 因为前端传递的json串，不光有手机号，还有验证码值，但是user表中只有phone，没有code
  * 可以在实体类中添加code属性，然后使用注解声明，不在数据库中
  * 也可以直接使用map去接收json串，自定义一个map即可，其实map和json结构很像 

```java
//验证码
@TableField(exist = false)//数据库不存在
private Integer code;
```

```java
/**
     * 用户登陆
     * 当把用户信息存入数据库后，会自动生成一个id，修改原user对象，
     * 即存入之前id为null，存入之后，id有值
     * @param user
     * @return
     */
    @PostMapping("/login")
    public R<User> UserLogin(@RequestBody User user,HttpServletRequest request){
        log.info(user.toString());

        //获取手机号和验证码，并去跟session域中的数据进行对比
        Integer code = (Integer) request.getSession().getAttribute(user.getPhone());
        if(!code.equals(user.getCode())){
            //如果验证码不一样
            return R.error("验证码不正确,请重新输入！");
        }
        //验证码一样
        // 如果是新用户，将用户信息存入数据库，并获取用户id；
        LambdaQueryWrapper<User> queryWrapper=new LambdaQueryWrapper<>();
        queryWrapper.eq(User::getPhone,user.getPhone());
        User user1 = userService.getOne(queryWrapper);

        if(user1==null){
            //将用户信息存入数据库
            userService.save(user);//这里保存之后，自动给user1对象生成了一个id------------------------------------------------------
//            log.info(user.toString());
            user1=user; //将保存好的user赋给user1 这样方便外面统一获取userId
//            log.info(user1.toString());
        }
        //如果是老用户，直接获取用户id
        Long userId = user1.getId();


        //将用户id存入session域
        request.getSession().setAttribute("user",userId);

        return R.success(user1);

    }
```

##### 主动登出

* 将消息从域中删除，直接用 `removeAttribute("user");`

```java
/**
 * 用户登出
 * @return
 */
@PostMapping("/loginout")
public R<String> UserLoginout(HttpServletRequest request){
    //将session中的用户id 取消
    request.getSession().removeAttribute("user");

    return R.success("退出成功！！");
}
```

# 瑞吉外卖移动端

### 地址簿相关功能

##### 新增地址

```java
/**
 * 新增
 */
@PostMapping
public R<AddressBook> save(@RequestBody AddressBook addressBook) {
    addressBook.setUserId(BaseContext.getCurrentId());
    log.info("addressBook:{}", addressBook);
    addressBookService.save(addressBook);
    return R.success(addressBook);
}
```

##### 设置默认地址

*  点击设置默认地址生效

* 在设置默认地址时，不需要查询状态在修改状态，直接把所有状态都设为0，即非默认，然后把传入的地址设为默认

```java
/**
 *  点击设置默认地址生效
 * 设置默认地址
 */
@PutMapping("default")
public R<AddressBook> setDefault(@RequestBody AddressBook addressBook) {
    log.info("addressBook:{}", addressBook);
    LambdaUpdateWrapper<AddressBook> wrapper = new LambdaUpdateWrapper<>();
    wrapper.eq(AddressBook::getUserId, BaseContext.getCurrentId());
    wrapper.set(AddressBook::getIsDefault, 0);
    //SQL:update address_book set is_default = 0 where user_id = ?
    addressBookService.update(wrapper);//将当前用户下所有的地址都设成0

    addressBook.setIsDefault(1);
    //SQL:update address_book set is_default = 1 where id = ?
    addressBookService.updateById(addressBook);//将刚刚传过来的地址设为1
    return R.success(addressBook);
}
```

##### 根据id查询地址

```java
/**
 * 根据id查询地址
 */
@GetMapping("/{id}")
public R<AddressBook> get(@PathVariable Long id) {
    AddressBook addressBook = addressBookService.getById(id);
    if (addressBook != null) {
        return R.success(addressBook);
    } else {
        return R.error("没有找到该对象");
    }
}
```

##### 查询默认地址

```java
/**
 * 查询默认地址
 */
@GetMapping("default")
public R<AddressBook> getDefault() {
    LambdaQueryWrapper<AddressBook> queryWrapper = new LambdaQueryWrapper<>();
    queryWrapper.eq(AddressBook::getUserId, BaseContext.getCurrentId());
    queryWrapper.eq(AddressBook::getIsDefault, 1);

    //SQL:select * from address_book where user_id = ? and is_default = 1
    AddressBook addressBook = addressBookService.getOne(queryWrapper);

    if (null == addressBook) {
        return R.error("没有找到该对象");
    } else {
        return R.success(addressBook);
    }
}
```

##### 查询指定用户的全部地址

```java
/**
 * 查询指定用户的全部地址
 */
@GetMapping("/list")
public R<List<AddressBook>> list(AddressBook addressBook) {
    addressBook.setUserId(BaseContext.getCurrentId());
    log.info("addressBook:{}", addressBook);

    //条件构造器
    LambdaQueryWrapper<AddressBook> queryWrapper = new LambdaQueryWrapper<>();
    queryWrapper.eq(null != addressBook.getUserId(), AddressBook::getUserId, addressBook.getUserId());
    queryWrapper.orderByDesc(AddressBook::getUpdateTime);

    //SQL:select * from address_book where user_id = ? order by update_time desc
    return R.success(addressBookService.list(queryWrapper));
}
```

##### 更新地址信息

```java
/**
 *点击小笔生效
 * 更新地址信息
 * @return
 */
@PutMapping
public R<String> updateAddressBook(@RequestBody  AddressBook addressBook){
    log.info(addressBook.toString());
    addressBookService.updateById(addressBook);
    return R.success("修改成功！");
}
```

##### 删除地址信息

```java
/**
 * 删除地址信息
 * @param ids
 * @return
 */
@DeleteMapping//传入 的是数组类中，用列表去接，需要加注解  @RequestParam
public R<String> deleteAddressBook(@RequestParam List<Long> ids){
    log.info(ids.toString());
    if(ids.isEmpty()){
        return R.error("删除失败!!");
    }
    addressBookService.removeBatchByIds(ids);
    return R.success("删除成功！");
}
```

### 菜品展示

##### 查询对应菜系下所有菜品

* 代码复用
  * 原先是在新增套餐的时候使用，只需要返回菜品信息即可
  * 现在移动端需要展示的不仅是菜品信息，还有菜品口味信息，所有修改了原先的返回值，使用dto对象
* 属性copy
  * `BeanUtils.copyProperties`不能直接作用于list集合
  * 需要对集合中的每一项单独操作才可以完成属性copy

```java
/**
     * 原本 后台，新增套餐时使用
     * 复用移动端，点击左侧 菜系名称时 生效
     *  根据categoryId,查询菜品名称
     * @param dish Dish 对象，现阶段只有categoryId一个值，但是复用性更好,这不是后期复用了status 查询状态
     * @return R<List<Dish>>  对应菜系id的全部菜品信息
     * @return R<List<DishDto>>  返回对应菜系id的全部菜品信息，同时返回菜品对应的口味信息，修改
     */
@GetMapping("/list")
public R<List<DishDto>> getDishList(Dish dish){

    //在后台管理页面 需要获取菜品信息，  这些就够了
    //创建查询对象
    LambdaQueryWrapper<Dish> queryWrapper=new LambdaQueryWrapper<>();
    //根据当前的categoryId 查询所有 在售卖阶段的菜品
    queryWrapper.eq(dish.getCategoryId()!=null,Dish::getCategoryId,dish.getCategoryId());
    queryWrapper.eq(Dish::getStatus,1);
    //排序条件
    queryWrapper.orderByAsc(Dish::getSort);//按排序 越小越好
    queryWrapper.orderByDesc(Dish::getUpdateTime);//按更新时间，越大越好
    //查询所有满足条件的排列好的数据
    List<Dish> dishes = dishService.list(queryWrapper);


    //在移动端展示的时候，需要展示菜品对应口味信息，所以要补加这些
    //新建dishDto对象，copy dishes的属性
    //        List<DishDto> dishDtos=new ArrayList<>();
    //        BeanUtils.copyProperties(dishes,dishDtos);---->这个copy方法不能直接作用于list集合


    //遍历每一个菜品，封装其口味信息
    List<DishDto> dishDtos=dishes.stream().map((item)->{
        //新建dishDto对象，并copy dish的值
        DishDto dishDto=new DishDto();
        BeanUtils.copyProperties(item,dishDto);
        //得到 dish_id
        Long dishId = item.getId();
        //查表 dish_flavor,得到口味信息
        LambdaQueryWrapper<DishFlavor> queryWrapper1=new LambdaQueryWrapper<>();
        queryWrapper1.eq(DishFlavor::getDishId,dishId);
        List<DishFlavor> dishFlavors = dishFlavorService.list(queryWrapper1);
        //保存每个菜品的口味信息
        dishDto.setFlavors(dishFlavors);
        return dishDto;
    }).collect(Collectors.toList());


    log.info(dishDtos.toString());
    return R.success(dishDtos);
}
```

##### 查询套餐简讯

```java
/**
 * 在移动端 展示套餐菜品的时候用到
 * 点击套餐种类可获得该种类下的所有售卖套餐 
 * 获取套餐的全部菜品
 * @param setmeal  套餐对象
 * @return
 */
@GetMapping("/list")
public R<List<Setmeal>> getSetMeal(Setmeal setmeal){ //问号接参数
    log.info(setmeal.toString());
    //根据 categoryId和status查询套餐的菜品
    LambdaQueryWrapper<Setmeal> queryWrapper=new LambdaQueryWrapper<>();
    queryWrapper.eq(setmeal.getCategoryId()!=null,Setmeal::getCategoryId,setmeal.getCategoryId())
                .eq(setmeal.getStatus()!=null,Setmeal::getStatus,setmeal.getStatus());//1表示在售
    //排序条件 按更新时间降序排列
    queryWrapper.orderByDesc(Setmeal::getUpdateTime);

    List<Setmeal> setmeals = setmealService.list(queryWrapper);

    return R.success(setmeals);

}
```

##### 查询套餐详情————未完

```java
/**
     * 移动端点击套餐后，弹出套餐对应菜品详情
     * 显示菜品
     * @param setmealId   套餐id
     * @return  返回套餐信息和套餐对应的菜品   dto对象list集合  R<SetmealDto>
     */
@GetMapping("dish/{setmealId}")
public R<List<SetmealDish>> getSetMeal(@PathVariable Long setmealId){//路径参数 直接接

    //        //新建 SetmealDto 对象
    //        SetmealDto setmealDto=new SetmealDto();

    //根据套餐id 查询对应菜品
    LambdaQueryWrapper<SetmealDish> queryWrapper=new LambdaQueryWrapper<>();
    queryWrapper.eq(setmealId!=null,SetmealDish::getSetmealId,setmealId);
    //根据修改时间降序排列,根据sort升序排列
    queryWrapper.orderByDesc(SetmealDish::getUpdateTime).orderByAsc(SetmealDish::getSort);
    List<SetmealDish> setmealDishes = setmealDishService.list(queryWrapper);
    //        //封装套餐内菜品信息
    //        setmealDto.setSetmealDishes(setmealDishes);


    //        //根据套餐id，查询套餐信息
    //        Setmeal setmeal = setmealService.getById(setmealId);
    //        //将套餐信息copy到dto对象中
    //        BeanUtils.copyProperties(setmeal,setmealDto);
    //        return R.success(setmealDto);

    return R.success(setmealDishes);


}
```

### 购物车

##### 获得购物车信息

```java
/**
 * 得到购物车信息
 * @return
 */
@GetMapping("/list")
public R<List<ShoppingCart>> getShoppingCartList(HttpServletRequest request){
    //根据当前用户id 查询 其购物车信息
    Long userId = (Long) request.getSession().getAttribute("user");
    LambdaQueryWrapper<ShoppingCart> queryWrapper=new LambdaQueryWrapper<>();
    queryWrapper.eq(userId!=null,ShoppingCart::getUserId,userId);
    List<ShoppingCart> shoppingCarts = shoppingCartService.list(queryWrapper);

    return R.success(shoppingCarts);
}
```

##### 增加菜品数量

* 需要添加用户id和创建时间，创建时间不能用公共字段自动添加的方法，因为那个方法同时需要两个参数，这里直接手动添加就好了
* 在增加数量之前，首先要拼上用户id的查询，每一个用户的购物车是不一样的
* 在增加菜品的时候，理论上来说，口味不同算不同的菜，但是前面前端没有考虑，在点加号的时候，会报错，所有这里不考虑口味

```java
/**
 * 传入菜品和套餐公用一个方法
 * 往购物车中添加菜品
 * @return
 */
@PostMapping("/add")
public R<ShoppingCart> addDish(@RequestBody ShoppingCart shoppingCart, HttpServletRequest request){
    log.info(shoppingCart.toString());
    //添加userId
    Long userId = (Long)request.getSession().getAttribute("user");
    shoppingCart.setUserId(userId);
    //添加创建时间
    //因为表中只有创建时间，没有修改时间，所以只能用这种方法来插入时间
    shoppingCart.setCreateTime(LocalDateTime.now());


    LambdaQueryWrapper<ShoppingCart> queryWrapper=new LambdaQueryWrapper<>();
    queryWrapper.eq(ShoppingCart::getUserId,userId);//当前 用户下
    //查询当前菜品或者套餐是否在购物车中  两个id只传入一个
    //查询套餐
    queryWrapper.eq(shoppingCart.getSetmealId()!=null,ShoppingCart::getSetmealId,shoppingCart.getSetmealId());
    //查询菜品,不考虑口味，前端没考虑
    queryWrapper.eq(shoppingCart.getDishId()!=null,ShoppingCart::getDishId,shoppingCart.getDishId());


    ShoppingCart setmeal_dish = shoppingCartService.getOne(queryWrapper);
    if(setmeal_dish!=null){
        //说明已经有了当前套餐，数量加一
        setmeal_dish.setNumber(setmeal_dish.getNumber()+1);
        shoppingCartService.updateById(setmeal_dish);
    }else{
        //如果不存在，则添加到购物车中，数量默认是1
        shoppingCartService.save(shoppingCart);
        setmeal_dish=shoppingCart;
    }

    return R.success(setmeal_dish);
}
```

##### 减少菜品数量

* ​    `if(number>1)`
  * 1 这个数字很精髓，不是0 
  *  因为数量为1的时候在点就不要减了，直接删除就好了

```java
/**
 *  从购物车中减少 菜品或套餐数量
 * @param shoppingCart
 * @return
 */
@PostMapping("/sub")
public R<ShoppingCart> subDish(@RequestBody ShoppingCart shoppingCart,HttpServletRequest request){
    log.info(shoppingCart.toString());
    //添加userId
    Long userId = (Long)request.getSession().getAttribute("user");
    shoppingCart.setUserId(userId);


    LambdaQueryWrapper<ShoppingCart> queryWrapper=new LambdaQueryWrapper<>();
    queryWrapper.eq(ShoppingCart::getUserId,userId);//当前 用户下
    //查询当前菜品或者套餐是否在购物车中  两个id只传入一个
    //查询套餐
    queryWrapper.eq(shoppingCart.getSetmealId()!=null,ShoppingCart::getSetmealId,shoppingCart.getSetmealId());
    //查询菜品,不考虑口味，前端没考虑
    queryWrapper.eq(shoppingCart.getDishId()!=null,ShoppingCart::getDishId,shoppingCart.getDishId());
    ShoppingCart setmeal_dish = shoppingCartService.getOne(queryWrapper);


    if(setmeal_dish!=null){
        Integer number = setmeal_dish.getNumber();
        log.info("{}",number);
        if(number>1){ //1 这个数字很精髓，不是0 是1,  因为数量为1的时候在点就不要减了，直接删除就好了
            //说明当前套餐存在，数量减一
            setmeal_dish.setNumber(setmeal_dish.getNumber()-1);
            shoppingCartService.updateById(setmeal_dish);
        }else{
            //如果当前套餐数量小于等于0 直接删除对应购物车信息
            shoppingCartService.removeById(setmeal_dish);
        }
    }else{
        return R.error("购物车中已没有当前菜品!");
    }
    return R.success(setmeal_dish);
}
```

##### 清空购物车

* `remove`方法 可以清除所有满足条件的数据 ，因此没有`removeBatch`方法

```java
/**
 * 清空购物车
 * @param request
 * @return
 */
@DeleteMapping("/clean")
public R<String> deleteShoppingCart(HttpServletRequest request){

    //查询当前userId
    Long userId = (Long)request.getSession().getAttribute("user");
    LambdaQueryWrapper<ShoppingCart> queryWrapper=new LambdaQueryWrapper<>();
    queryWrapper.eq(userId!=null,ShoppingCart::getUserId,userId);
    shoppingCartService.remove(queryWrapper);//没有removeBatch方法， 会清除所有满足要求的数据 

    return R.success("成功清空购物车！！");

}
```

### 下单

##### 提交订单

* 因为前端网页提交过来的数据很少，用来封装数据库orders表和order_detail表，信息不足，所以需要自己来设置信息。
* 补充用户名和手机号，要加上非空判断
* 补充地址数据，在查地址对象的时候，加入非空判断，防小人；还有使用三目运算符拼接详细地址
* 生成订单号
  * `    long orderId = IdWorker.getId();`      `mybatisplus`提供的功能
  * 类型是 `long`,转换成字符串`String.valueOf(orderId)`，因为long是基本数据类型，所以不能用强转的方式
* 计算钱数
  * 使用`AtomicInteger amount=new AtomicInteger(0); ` ，表示总钱数，原子操作，高并发安全
  * ` amount.addAndGet(item.getAmount().multiply(new BigDecimal(item.getNumber())).intValue());`
  * 使用对应的方法完成加乘运算，计算总的钱数
  * `orders.setAmount(new BigDecimal(amount.get()));` 数据库使用的存钱的类型是`BigDecimal`，所以传的时候要转换一下
* 属性copy
  * `BeanUtils.copyProperties(item,orderDetail,"id");`忽略了id
  * **属性copy的时候不要求两个对象的属性完全一样，或者一个对象拥有另一个对象的全部属性，只要有相同的属性即可**
  * **copy的时候，会将相同的属性，copy过去，至于两边各自独有的属性，无所谓，不考虑。**

```java
/**
     * /提交订单
     * @param orders
     */
@Transactional
public void submit(Orders orders){
    //查询用户id
    Long userId = BaseContext.getCurrentId();


    //补充用户数据
    User user = userService.getById(userId);
    if(user.getName()!=null){
        orders.setUserName(user.getName());//用户名
    }
    if(user.getPhone()!=null){
        orders.setPhone(user.getPhone());//手机号
    }


    //补充地址数据
    AddressBook addressBook = addressBookService.getById(orders.getAddressBookId());
    if(addressBook==null){
        //仿小人，为空不能下单
        throw  new CustomException("用户地址信息有误，不能下单");
    }
    orders.setConsignee(addressBook.getConsignee()); //收货人
    orders.setAddress((addressBook.getProvinceName()==null ? "":addressBook.getProvinceName())
                      +(addressBook.getCityName()==null ? "":addressBook.getCityName())
                      +(addressBook.getDistrictName()==null? "" :addressBook.getDistrictName())
                      +(addressBook.getDetail()==null? "":addressBook.getDetail()));//详细地址


    //查询当前购物车数据
    LambdaQueryWrapper<ShoppingCart> queryWrapper=new LambdaQueryWrapper<>();
    queryWrapper.eq(ShoppingCart::getUserId,userId);
    List<ShoppingCart> shoppingCarts = shoppingCartService.list(queryWrapper);
    if(shoppingCarts==null || shoppingCarts.size()==0){
        //仿小人，为空不能下单
        throw  new CustomException("购物车为空,不能下单");
    }


    //补充基本信息

    orders.setUserId(userId);//用户id
    long orderId = IdWorker.getId();
    orders.setNumber(String.valueOf(orderId));//订单号
    orders.setId(orderId);//直接将订单号设置为id  不用自己生成
    orders.setStatus(2);//2表示代派送
    orders.setOrderTime(LocalDateTime.now());//下单时间
    orders.setCheckoutTime(LocalDateTime.now());//支付时间


    //计算钱数及补充订单详情信息
    AtomicInteger amount=new AtomicInteger(0);//原子操作，可以保证并发安全
    List<OrderDetail> orderDetails=shoppingCarts.stream().map((item)->{
        //设置订单详情
        OrderDetail orderDetail=new OrderDetail();
        orderDetail.setOrderId(orderId);//设置订单id
        //这个方法会copy所有相同的属性，自动忽略没有的属性，不会报错
        //这里item 多了id，user_Id,create_time, 在复制的时候自动忽略了
        //这里orderDetail 少了 order_id,id
        BeanUtils.copyProperties(item,orderDetail,"id");//忽略id，让其自动生成
        log.info(orderDetail.toString());

        //顺便计算钱数
        //钱数用 BigDecimal 类型  amount是这个类型，将number转成这个类型
        //乘完之后，用 intValue获取值，在用addAndGet 自增赋值给amount
        amount.addAndGet(item.getAmount().multiply(new BigDecimal(item.getNumber())).intValue());

        return orderDetail;
    }).collect(Collectors.toList());

    //将订单信息保存
    orders.setAmount(new BigDecimal(amount.get()));//得到数值，转换成BigDecimal类型
    this.save(orders);


    //将订单详情保存
    orderDetailService.saveBatch(orderDetails);

    //删除购物车信息
    shoppingCartService.remove(queryWrapper);

}
```







































